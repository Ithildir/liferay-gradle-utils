import groovy.io.FileType

import org.apache.commons.codec.digest.DigestUtils
import org.apache.commons.lang3.StringUtils

buildscript {
	dependencies {
		classpath "commons-codec:commons-codec:1.10"
		classpath "org.apache.commons:commons-lang3:3.4"
	}

	repositories {
		mavenLocal()

		maven {
			url "http://cdn.repository.liferay.com/nexus/content/groups/public"
		}
	}
}

plugins {
	id "de.undercouch.download" version "1.2"
}

defaultTasks "copyLibsToCache"

ext {
	modulesDir = new File("S:/lr/liferay-portal/modules")
}

repositories {
	mavenLocal()

	maven {
		url "http://cdn.repository.liferay.com/nexus/content/groups/public"
	}
}

File gradleCacheDir = new File(modulesDir, "../.gradle/caches/modules-2/files-2.1")

task checkBndInclude
task checkBndInstructions
task checkCache
task copyLibToCache
task copyLibsToCache
task checkMPBnd
task copyRemoteLibToCache
task deleteIvyXml(type: Delete)
task fixBnd
task fixCache
task moveModules
task replaceBuildXml
task wrapper(type: Wrapper)
task writeSettingsIncludes

checkBndInclude << {
	def bndFiles = fileTree(dir: modulesDir, include: "**/bnd.bnd")

	bndFiles.each {
		File bndFile ->

		Properties bndProperties = new Properties()

		bndFile.withInputStream {
			bndProperties.load it
		}

		String include = bndProperties["-include"]

		if (include) {
			println include
		}
	}
}

checkBndInstructions << {
	def bndInstructions = new TreeSet<String>()

	def bndFiles = fileTree(dir: modulesDir, include: "**/bnd.bnd")

	bndFiles.each {
		bndFile ->

		def bndProperties = new Properties()

		bndFile.withInputStream {
			bndProperties.load it
		}

		bndInstructions.addAll(bndProperties.stringPropertyNames())
	}

	bndInstructions.each {
		println it
	}
}

checkCache << {
	gradleCacheDir.eachFileRecurse(FileType.FILES) {
		File file ->

		String sha1 = _getSHA1(file)

		if (file.parentFile.name != sha1) {
			println "This file is in a directory with a wrong SHA1: " + file
		}
	}
}

checkMPBnd << {
	def appPackages = new HashMap<String, Set<String>>()

	def bndFileTree = fileTree(dir: new File(modulesDir, "../marketplace"), include: "*/bnd.bnd")

	bndFileTree.each {
		File bndFile ->

		def bndProperties = new Properties()

		bndFile.withInputStream {
			bndProperties.load it
		}

		def appsString = bndProperties["Liferay-Releng-Dependent-Apps"]

		def apps = appsString.tokenize(",")

		apps.each {
			app ->

			app = app.trim()

			def index = app.indexOf(":")

			app = app.substring(0, index)

			Set<String> packages = appPackages[app]

			if (packages == null) {
				packages = new HashSet<String>()

				appPackages[app] = packages
			}

			packages << bndFile.parentFile.name
		}
	}

	appPackages.each {
		app, packages ->

		if (packages.size() > 1) {
			println "${app} is in ${packages}"
		}
	}
}

copyLibToCache << {
	_copyLibToCache(project, gradleCacheDir, project.properties["libGroup"], project.properties["libName"], project.properties["libVersion"], project.properties["libClassifier"])
}

copyLibsToCache {
	doLast {
		File libsFile = file("libs.txt")

		libsFile.eachLine {
			String line ->

			if (line.startsWith("#")) {
				return
			}

			List<String> tokens = line.tokenize(":")

			String libGroup = null
			String libName = null
			String libVersion = null
			String libClassifier = null

			if (tokens.size() == 2) {
				libGroup = "com.liferay"
				libName = tokens[0]
				libVersion = tokens[1]
			}
			else {
				libGroup = tokens[0]
				libName = tokens[1]
				libVersion = tokens[2]

				if (tokens.size() == 4) {
					libClassifier = tokens[3]
				}
			}

			_copyLibToCache(project, gradleCacheDir, libGroup, libName, libVersion, libClassifier)
		}
	}

	finalizedBy {
		fixCache
	}
}

copyRemoteLibToCache << {
	if (!project.hasProperty("libGroup") || !project.hasProperty("libName") || !project.hasProperty("libVersion")) {
		throw new GradleException("libGroup, libName, and libVersion are required")
	}

	def dependency = dependencies.create group: libGroup, name: libName, version: libVersion

	def configuration = configurations.detachedConfiguration dependency

	configuration.resolve()
}

deleteIvyXml {
	delete fileTree(dir: modulesDir, include: "**/ivy.xml")
}

fixBnd << {
	ant.fixcrlf eof: "remove", fixlast: false, includes: "**/bnd.bnd", srcDir: modulesDir, tab: "add", tablength: 4

	def bndFiles = fileTree(dir: modulesDir, include: "**/bnd.bnd")

	bndFiles.each {
		it.text = it.text.trim()
	}
}

fixCache << {
	gradleCacheDir.eachFileRecurse(FileType.FILES) {
		def file ->

		if (file.name.endsWith(".pom")) {
			def charsetToolkit = new CharsetToolkit(file)
			def charset = charsetToolkit.charset.name()

			ant.fixcrlf encoding: charset, eol: "lf", file: file, fixlast: false, outputencoding: "UTF-8"
		}

		def sha1 = _getSHA1(file)

		def dir = file.parentFile

		if (dir.name != sha1) {
			def success = dir.renameTo(new File(dir.parentFile, sha1))

			if (success) {
				println "Succesfully moved " + dir
			}
			else {
				delete dir

				println "Deleted " + dir
			}
		}
	}
}

moveModules {
	finalizedBy replaceBuildXml
}

moveModules << {
	File marketplaceDir = new File(modulesDir, "apps/marketplace")

	if (marketplaceDir.exists()) {
		throw new GradleException("Please rename " + marketplaceDir + ", it messes with the bnd.bnd relative path replacement")
	}

	def moveDirs = [:]
	def moveParentDirs = new HashSet<File>()

	def movesFile = file("moves.csv")

	def moveLines = movesFile.readLines()

	moveLines.each {
		if (!it.startsWith("modules")) {
			println "Ignoring " + it

			return
		}

		def tokens = it.tokenize(",")

		def oldParentDir = new File(modulesDir.parentFile, tokens[0])
		def dirName = tokens[1]
		def newParentDir = new File(new File(modulesDir, "apps"), tokens[2])

		moveParentDirs << newParentDir

		def oldDir = new File(oldParentDir, dirName)

		if (!oldDir.exists()) {
			println "Ignoring ${oldDir} because it does not exist"

			return
		}

		def newDir = new File(newParentDir, dirName)

		newParentDir.mkdirs()

		def dir = newParentDir

		while ((dir != null) && (dir != modulesDir)) {
			def buildXmlFile = new File(dir, "build.xml")

			if (!buildXmlFile.exists()) {
				buildXmlFile.text = "REPLACEME!"
			}

			dir = dir.parentFile
		}

		def moved = oldDir.renameTo(newDir)

		if (!moved) {
			throw new GradleException("Unable to move ${oldDir} to ${newDir}")
		}

		println "Moved ${oldDir} to ${newDir}"

		moveDirs[oldDir] = newDir
	}

	Closure doReplace = {
		file, replaceClosure ->

		def content = file.text

		def newContent = content

		moveDirs.each {
			oldDir, newDir ->

			newContent = newContent.replace replaceClosure(oldDir), replaceClosure(newDir)
		}

		if (content != newContent) {
			file.text = newContent

			println "Updated " + file
		}
	}

	if (Boolean.getBoolean("skip.replace")) {
		return
	}

	// Replace relative paths in bnd.bnd

	moveParentDirs.each {
		parentDir ->

		def bndFileTree = fileTree(dir: parentDir, exclude: "**/src/**/*.bnd", include: "**/*.bnd")

		bndFileTree.each {
			bndFile ->

			def bndDir = bndFile.parentFile

			def bndDirPath = bndDir.toPath()

			def content = bndFile.text

			def newContent = content.replaceAll(
				/((?:\.\.\/)+[\w-]+?)\//,
				{
					def pointedFile = new File(bndDir, it[1])

					while (!pointedFile.exists()) {
						def dir = pointedFile.parentFile.parentFile

						if (!dir) {
							pointedFile = null

							break
						}

						pointedFile = new File(dir, pointedFile.name)
					}

					if (pointedFile == null) {
						println "Unable to replace ${it[1]} in ${bndFile}"

						return it[1]
					}

					def pointedPath = bndDirPath.relativize(pointedFile.toPath()).toString()

					return pointedPath.replace(File.separatorChar, '/' as char) + "/"
				})

			if (content != newContent) {
				bndFile.text = newContent

				println "Updated " + bndFile
			}
		}
	}

	// Replace project paths in build.gradle

	def buildGradleFiles = fileTree(dir: modulesDir, include: "**/build.gradle")

	buildGradleFiles.each {
		doReplace it, {
			dir ->

			def modulesDirPath = modulesDir.toPath()

			def path = modulesDirPath.relativize(dir.toPath()).toString()

			path = path.replace(File.separatorChar, ':' as char)
			path = path.replace('/' as char, ':' as char)

			return "\":" + path + ":"
		}
	}

	// Replace file paths source-formatter.properties and other files

	FileTree fileTree = fileTree(dir: modulesDir.parentFile, includes: ["source-formatter.properties", "modules/**/*.bnd", "modules/**/*.java"])

	fileTree.each {
		doReplace it, {
			dir ->

			def modulesDirPath = modulesDir.toPath()

			def path = modulesDirPath.relativize(dir.toPath()).toString()

			return "modules/" + path.replace(File.separatorChar, '/' as char) + "/"
		}
	}
}

replaceBuildXml << {
	def buildXmlFileTree = fileTree(dir: modulesDir, include: "**/build.xml")

	def buildModuleXmlPath = new File(modulesDir, "build-module.xml").toPath()

	buildXmlFileTree.each {
		def buildXmlFile ->

		if (buildXmlFile.parentFile.name != "samples") {
			def parentPath = buildXmlFile.parentFile.toPath()

			def content = buildXmlFile.text

			if (content.contains("build-theme.xml")) {
				return
			}

			def buildModuleXmlFileName = parentPath.relativize(buildModuleXmlPath).toString()

			buildModuleXmlFileName = buildModuleXmlFileName.replace('\\', '/')

			buildXmlFile.text = """\
<?xml version=\"1.0\"?>
<!DOCTYPE project>

<project>
	<import file=\"${buildModuleXmlFileName}\" />
</project>"""
		}
	}
}

wrapper {
	gradleVersion = "2.11"
}

writeSettingsIncludes << {
	def settingsIncludes = []

	def xmlParser = new XmlParser()

	xmlParser.setFeature "http://apache.org/xml/features/disallow-doctype-decl", false

	def buildXmlFile = new File(modulesDir, "build.xml")

	def projectNode = xmlParser.parse(buildXmlFile)

	projectNode.path.dirset.each {
		def node ->

		def dir = node.attribute("dir")
		def excludes = node.attribute("excludes") ?: ""
		def includes = node.attribute("includes") ?: ""

		def dirNames = excludes.tokenize(",")

		dirNames.each {
			def dirName ->

			settingsIncludes << "exclude \"${dir}/${dirName}/build.gradle\""
		}

		dirNames = includes.tokenize(",")

		dirNames.each {
			def dirName ->

			settingsIncludes << "include \"${dir}/${dirName}/build.gradle\""
		}
	}

	settingsIncludes.sort()

	def settingsIncludesFile = file("tmp/settings-includes.gradle")

	settingsIncludesFile.parentFile.mkdirs()

	settingsIncludesFile.withWriter {
		def writer ->

		def previousTitle

		settingsIncludes.each {
			def title = it.substring(0, it.indexOf(' '))

			if (previousTitle && (previousTitle != title)) {
				writer.writeLine
			}

			writer.write "\t\t"
			writer.writeLine it
		}
	}
}

private void _copyLibToCache(Project project, File gradleCacheDir, String libGroup, String libName, String libVersion, String libClassifier) {
	if (!libGroup || !libName || !libVersion) {
		throw new GradleException("libGroup, libName, and libVersion are required")
	}

	String mavenLibGroup = libGroup.replace('.', '/')

	File gradleLibDir = new File(gradleCacheDir, "${libGroup}/${libName}/${libVersion}")
	File mavenLibDir = new File(System.getProperty("user.home"), ".m2/repository/${mavenLibGroup}/${libName}/${libVersion}")

	["jar", "pom"].each {
		String extension ->

		String sourceFileName = "${libName}-${libVersion}"

		if (libClassifier) {
			if (extension != "jar") {
				return
			}

			sourceFileName += "-${libClassifier}"
		}

		sourceFileName += ".${extension}"

		File sourceFile = new File(mavenLibDir, sourceFileName)

		if (!sourceFile.exists()) {
			String sourceUrl = "https://repository.liferay.com/nexus/content/groups/public/${mavenLibGroup}/${libName}/${libVersion}/${sourceFileName}"

			try {
				project.download {
					dest buildDir
					src sourceUrl
				}
			}
			catch (Exception e) {
				println e

				return
			}

			sourceFile = new File(buildDir, sourceFileName)
		}

		String sha1 = _getSHA1(sourceFile)

		project.copy {
			from sourceFile
			into new File(gradleLibDir, sha1)
		}
	}
}

private String _getSHA1(File file) {
	file.withInputStream {
		String sha1 = DigestUtils.sha1Hex(it)

		StringUtils.stripStart(sha1, "0")
	}
}