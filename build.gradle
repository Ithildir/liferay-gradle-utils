import com.liferay.portal.kernel.util.UnicodeProperties

import java.util.zip.ZipFile

import groovy.io.FileType
import groovy.io.FileVisitResult

import org.apache.commons.codec.digest.DigestUtils
import org.apache.commons.lang3.StringUtils

buildscript {
	dependencies {
		classpath "com.liferay.portal:com.liferay.portal.kernel:latest.release"
		classpath "commons-codec:commons-codec:1.10"
		classpath "org.apache.commons:commons-lang3:3.4"
	}

	repositories {
		mavenLocal()

		mavenCentral()
	}
}

plugins {
	id "de.undercouch.download" version "3.0.0"
}

defaultTasks "copyLibsToCache"

ext {
	portalDir = new File("S:/lr/liferay-portal")
	portal62Dir = new File("S:/lr/liferay-portal-6.2.x")

	gradleCacheDir = new File(portalDir, ".gradle/caches/modules-2/files-2.1")
	modulesDir = new File(portalDir, "modules")
}

repositories {
	mavenLocal()

	mavenCentral()
}

task addPortalBuild
task addStaticBuild
task checkBndInclude
task checkBndInstructions
task checkBndServiceInstructions
task checkBrokenJarsKernel
task checkCache
task checkJenkins
task checkKeywords
task checkImplicitPortlets
task checkPortlets
task consolidateLang
task copyLibToCache
task copyLibsToCache
task checkMPBnd
task copyRemoteLibToCache
task checkResources
task deleteBuildXml(type: Delete)
task deleteIvyXml(type: Delete)
task deletePackageInfo
task deletePortalBuild(type: Delete)
task fixBnd
task fixCache
task fixPackageInfo
task fixSeparateRepoDeps
task fixShrinkwrap
task initPortalBuild
task initSeparateRepos
task moveLPS64532
task moveModules
task moveStatic
task printExtensions
task removeTouch
task renameBuildFiles
task replaceBuildXml
task replaceProjectDeps
task wrapper(type: Wrapper)
task writeSettingsIncludes

addPortalBuild << {
	def buildXmlFiles = fileTree(dir: modulesDir, exclude: "*/**/samples/", include: "*/**/build.xml")

	buildXmlFiles.each {
		def portalBuildFile = new File(it.parentFile, "portal.build")

		if (portalBuildFile.exists()) {
			return
		}

		def created = portalBuildFile.createNewFile()

		if (created) {
			println "Created " + portalBuildFile
		}
		else {
			throw new GradleException("Unable to create " + portalBuildFile)
		}
	}
}

addStaticBuild << {
	def bndFiles = fileTree(dir: modulesDir, include: "**/bnd.bnd")

	def staticDeployDir = 'liferay {\n\tdeployDir = file("${liferayHome}/osgi/static")\n}'

	bndFiles.each {
		def dir = it.parentFile

		def staticBuildFile = new File(dir, "static.build")

		if (staticBuildFile.exists()) {
			return
		}

		def buildGradleFile = new File(dir, "build.gradle")

		if (!buildGradleFile.exists()) {
			return
		}

		def buildGradle = buildGradleFile.text

		buildGradle = buildGradle.replace('\r', '')

		if (!buildGradle.contains(staticDeployDir)) {
			return
		}

		def created = staticBuildFile.createNewFile()

		if (created) {
			println "Created " + staticBuildFile
		}
		else {
			throw new GradleException("Unable to create " + staticBuildFile)
		}

		buildGradleFile.text = buildGradle.replace(staticDeployDir, '')
	}
}

checkBndInclude << {
	def bndFiles = fileTree(dir: modulesDir, include: "**/bnd.bnd")

	bndFiles.each {
		File bndFile ->

		Properties bndProperties = new Properties()

		bndFile.withInputStream {
			bndProperties.load it
		}

		String include = bndProperties["-include"]

		if (include) {
			def includeList = include.tokenize(",")

			def dir = bndFile.parentFile

			includeList.each {
				def includedFile = new File(dir, it)

				if (!includedFile.exists()) {
					throw new GradleException("${includedFile.canonicalPath} is included in ${bndFile} but it does not exist")
				}
			}

			println include
		}
	}
}

checkBndInstructions << {
	def bndInstructions = new TreeSet<String>()

	def bndFiles = fileTree(dir: modulesDir, include: "**/bnd.bnd")

	bndFiles.each {
		bndFile ->

		def bndProperties = new Properties()

		bndFile.withInputStream {
			bndProperties.load it
		}

		bndInstructions.addAll(bndProperties.stringPropertyNames())
	}

	bndInstructions.each {
		println it
	}
}

checkBndServiceInstructions << {
	def bndFiles = fileTree(dir: modulesDir, include: "**/bnd.bnd")

	def expectedProperties = [:]

	expectedProperties["-liferay-spring-dependency"] = 'com.liferay.portal.spring.extender.service.ServiceReference'
	expectedProperties["Liferay-Spring-Context"] = 'META-INF/spring'
	expectedProperties["Require-Capability"] = 'liferay.extender;filter:="(&(liferay.extender=spring.extender)(version>=1.0)(!(version>=2.0)))"'

	bndFiles.each {
		bndFile ->

		def bndProperties = new Properties()

		bndFile.withInputStream {
			bndProperties.load it
		}

		if (!bndProperties["Liferay-Service"]) {
			return
		}

		def dir = bndFile.parentFile

		def buildGradleFile = new File(dir, "build.gradle")

		if (!buildGradleFile.text.contains("com.liferay.portal.spring.extender")) {
			throw new GradleException("Unable to find 'com.liferay.portal.spring.extender' in ${buildGradleFile}")
		}

		expectedProperties.each {
			k, v ->

			if (bndProperties[k] != v) {
				throw new GradleException("Unable to find ${k}=${v} in ${bndFile}")
			}
		}

		println "Checked ${dir}"
	}
}

checkBrokenJarsKernel << {
	def jarFileTree = fileTree(dir: gradleCacheDir, include: "com.liferay/**/*.jar")

	jarFileTree.each {
		jarFile ->

		def zipFile = new ZipFile(jarFile)

		zipFile.entries().each {
			zipEntry ->

			if (zipEntry.directory && zipEntry.name.endsWith("/kernel/")) {
				println jarFile
			}
		}
	}
}

checkCache << {
	gradleCacheDir.eachFileRecurse(FileType.FILES) {
		File file ->

		String sha1 = _getSHA1(file)

		if (file.parentFile.name != sha1) {
			println "This file is in a directory with a wrong SHA1: " + file
		}
	}
}

checkMPBnd << {
	def appPackages = new HashMap<String, Set<String>>()

	def bndFileTree = fileTree(dir: new File(modulesDir, "../marketplace"), include: "*/bnd.bnd")

	bndFileTree.each {
		File bndFile ->

		def bndProperties = new Properties()

		bndFile.withInputStream {
			bndProperties.load it
		}

		def appsString = bndProperties["Liferay-Releng-Dependent-Apps"]

		def apps = appsString.tokenize(",")

		apps.each {
			app ->

			app = app.trim()

			def index = app.indexOf(":")

			app = app.substring(0, index)

			Set<String> packages = appPackages[app]

			if (packages == null) {
				packages = new HashSet<String>()

				appPackages[app] = packages
			}

			packages << bndFile.parentFile.name
		}
	}

	appPackages.each {
		app, packages ->

		if (packages.size() > 1) {
			println "${app} is in ${packages}"
		}
	}
}

checkJenkins << {
	println "Checking ${reportMatch} in ${reportUrl}..."

	File reportFile = new File(temporaryDir, "report.html")

	exec {
		args = ["-O", reportFile.name, reportUrl]
		executable = "wget"
		workingDir = reportFile.parentFile
	}

	reportFile.text.eachMatch(/"(https:\/\/[^"]+\/\/console)"/) {
		def consoleUrl = it[1] + "Text"

		def consoleFile = new File(temporaryDir, "console.txt")

		exec {
			args = ["-O", consoleFile.name, consoleUrl]
			executable = "wget"
			workingDir = consoleFile.parentFile
		}

		if (consoleFile.text.contains(reportMatch)) {
			println "\"${reportMatch}\" found in ${consoleUrl}"

			throw new StopExecutionException()
		}
	}
}

checkKeywords << {
	if (!project.hasProperty("dir")) {
		throw new GradleException("Please pass -Pdir argument")
	}

	def keywordsFile = file("keywords.txt")

	def keywords = keywordsFile.readLines()

	def foundKeywords = new HashSet<String>()

	def fileTree = fileTree(dir: new File(modulesDir, dir))

	fileTree.each {
		def content = it.text

		keywords.each {
			if (content.contains(it)) {
				foundKeywords << it
			}
		}
	}

	println "Keywords not found: " + (keywords - foundKeywords)
}

checkImplicitPortlets << {
	def portletFileTree = fileTree(dir: modulesDir, exclude: "**/WEB-INF/", include: "apps/**/*Portlet.java")

	portletFileTree.each {
		if (it.text.contains("javax.portlet.name")) {
			return
		}

		println it
	}
}

checkPortlets << {
	def portletFileTree = fileTree(dir: modulesDir, excludes: ["**/portal-monitoring/", "**/portal-osgi-web-portlet-container-test/", "**/portal-portlet-bridge-soy/"], include: "**/*Portlet.java")

	portletFileTree.each {
		def dir = it.parentFile

		while (true) {
			def bndBndFile = new File(dir, "bnd.bnd")

			if (bndBndFile.exists()) {
				break
			}

			dir = dir.parentFile
		}

		if (!dir.name.endsWith("-web")) {
			throw new GradleException("${dir.name} should ends with -web")
		}

		println "${dir.name} is okay"
	}
}

consolidateLang << {
	if (!project.hasProperty("langKeys")) {
		throw new GradleException("Please pass -PlangKeys argument")
	}

	if (!project.hasProperty("langFrom")) {
		throw new GradleException("Please pass -PlangFrom argument")
	}

	def langKeysList = langKeys.tokenize(",")

	def moduleDir = file(langFrom)

	if (!moduleDir.exists()) {
		moduleDir = _getModuleDir(langFrom)
	}

	if (moduleDir == null) {
		throw new GradleException("Unable to find ${langFrom} in ${modulesDir}")
	}

	def contentDir = new File(moduleDir, "src/main/resources/content")

	if (!contentDir.exists()) {
		contentDir = new File(moduleDir, "docroot/WEB-INF/src/content")

		if (!contentDir.exists()) {
			throw new GradleException("Unable to find ${contentDir}")
		}
	}

	def contentDestDir = new File(portalDir, "portal-impl/src/content")

	def langFileTree = fileTree(dir: contentDir, include: "Language*.properties")

	langFileTree.each {
		langFile ->

		def destLangFile = new File(contentDestDir, langFile.name)

		if (!destLangFile.exists()) {
			throw new GradleException("Unable to find " + destLangFile)
		}

		UnicodeProperties langProperties = new UnicodeProperties()

		langProperties.load langFile.getText("UTF-8")

		langKeysList.each {
			key ->

			def value = langProperties[key]

			if (!value) {
				println "Unable to find ${key} in ${langFile}"

				return
			}

			destLangFile.withWriterAppend("UTF-8") {
				it.write "\n${key}=${value}"
			}

			println "Copied ${key}=${value} from ${langFile} to ${destLangFile}"
		}
	}
}

copyLibToCache << {
	_copyLibToCache(project, gradleCacheDir, project.properties["libGroup"], project.properties["libName"], project.properties["libVersion"], project.properties["libClassifier"])
}

copyLibsToCache {
	doLast {
		File libsFile = file("libs.txt")

		libsFile.eachLine {
			String line ->

			if (line.startsWith("#")) {
				return
			}

			List<String> tokens = line.tokenize(":")

			String libGroup = null
			String libName = null
			String libVersion = null
			String libClassifier = null

			if (tokens.size() == 2) {
				libGroup = "com.liferay"
				libName = tokens[0]
				libVersion = tokens[1]
			}
			else {
				libGroup = tokens[0]
				libName = tokens[1]
				libVersion = tokens[2]

				if (tokens.size() == 4) {
					libClassifier = tokens[3]
				}
			}

			_copyLibToCache(project, gradleCacheDir, libGroup, libName, libVersion, libClassifier)
		}
	}

	finalizedBy {
		fixCache
	}
}

copyRemoteLibToCache << {
	if (!project.hasProperty("libGroup") || !project.hasProperty("libName") || !project.hasProperty("libVersion")) {
		throw new GradleException("libGroup, libName, and libVersion are required")
	}

	def dependency = dependencies.create group: libGroup, name: libName, version: libVersion

	def configuration = configurations.detachedConfiguration dependency

	configuration.resolve()
}

checkResources << {
	// def resourcesFileTree = fileTree(dir: modulesDir, excludes: ["**/packageinfo", "**/internal/"], include: "apps/web-experience/**/src/main/resources/com/")
	def resourcesFileTree = fileTree(dir: modulesDir, excludes: ["sdk/gradle-templates/", "**/src/*/java/**/*.java", "**/source_formatter.ignore"], include: "**/src/*/java/")

	resourcesFileTree.each {
		println it
	}
}

deleteBuildXml {
	delete fileTree(dir: modulesDir, exclude: "**/samples/", include: "*/**/build.xml")
}

deleteIvyXml {
	delete fileTree(dir: modulesDir, include: "**/ivy.xml")
}

deletePackageInfo << {
	def bndFiles = fileTree(dir: modulesDir, include: "**/bnd.bnd")

	bndFiles.each {
		bndFile ->

		def moduleDir = bndFile.parentFile

		Properties bndProperties = new Properties()

		bndFile.withInputStream {
			bndProperties.load it
		}

		def packageInfoExcludes = []

		def exportPackage = bndProperties["Export-Package"]

		if (exportPackage) {
			def exportedPackages = exportPackage.split(",")

			packageInfoExcludes = exportedPackages.collect {
				"src/main/resources/" + it.replace('.' as char, '/' as char) + "/packageinfo"
			}

			println packageInfoExcludes
		}

		delete fileTree(dir: moduleDir, excludes: packageInfoExcludes, include: "**/packageinfo")
	}
}

deletePortalBuild {
	delete fileTree(dir: modulesDir, include: "**/portal.build")
}

fixBnd << {
	ant.fixcrlf eof: "remove", fixlast: false, includes: "**/bnd.bnd", srcDir: modulesDir, tab: "add", tablength: 4

	def bndFiles = fileTree(dir: modulesDir, include: "**/bnd.bnd")

	bndFiles.each {
		it.text = it.text.trim()
	}
}

fixCache << {
	gradleCacheDir.eachFileRecurse(FileType.FILES) {
		def file ->

		if (file.name.endsWith(".pom")) {
			def charsetToolkit = new CharsetToolkit(file)
			def charset = charsetToolkit.charset.name()

			ant.fixcrlf encoding: charset, eol: "lf", file: file, fixlast: false, outputencoding: "UTF-8"
		}

		def sha1 = _getSHA1(file)

		def dir = file.parentFile

		if (dir.name != sha1) {
			def success = dir.renameTo(new File(dir.parentFile, sha1))

			if (success) {
				println "Succesfully moved " + dir
			}
			else {
				delete dir

				println "Deleted " + dir
			}
		}
	}
}

fixPackageInfo << {
	def rootDir = new File(portalDir, "portal-kernel/src/com/liferay")
	def oldRootDir = new File(portal62Dir, "portal-service/src/com/liferay")

	def rootDirPath = rootDir.toPath()

	rootDir.eachDirRecurse {
		dir ->

		def packageInfoFile = new File(dir, "packageinfo")

		def javaFileTree = fileTree(dir: dir, include: "*.java")

		if (javaFileTree.empty) {
			if (packageInfoFile.exists()) {
				delete packageInfoFile

				println "Deleted " + packageInfoFile
			}

			return
		}

		def relativePath = rootDirPath.relativize(dir.toPath()).toString()

		def oldDir = new File(oldRootDir, relativePath)

		if (oldDir.exists()) {
			if (!packageInfoFile.exists() || !packageInfoFile.text.startsWith("version 7")) {
				packageInfoFile.text = "version 7.0.0"
			}
		}
		else {
			if (!packageInfoFile.exists() || packageInfoFile.text.startsWith("version 7")) {
				packageInfoFile.text = "version 1.0.0"
			}
		}
	}
}

fixSeparateRepoDeps << {
	def buildGradleFileTree = fileTree(dir: modulesDir, include: "**/build.gradle")

	def fixProjectPath = {
		dir ->

		File subRootDir = dir.parentFile

		while (true) {
			File settingsGradleFile = new File(subRootDir, "settings.gradle")

			if (settingsGradleFile.exists()) {
				break;
			}

			subRootDir = subRootDir.parentFile
		}

		URI subRootURI = subRootDir.toURI()

		String dirName = subRootURI.relativize(dir.toURI())

		dirName = dirName[0 .. -2]

		dirName.replace("/" as char, ":" as char)
	}

	buildGradleFileTree.each {
		buildGradleFile ->

		def buildGradle = buildGradleFile.text

		if (!buildGradle.contains("project(\"")) {
			return
		}

		buildGradle = buildGradle.replaceAll(/project\(":(.+)"\)/) {
			String projectDependency = it[0]
			String projectPath = it[1]

			def projectDirName = projectPath.replace(':' as char, File.separatorChar)

			def projectDir = new File(modulesDir, projectDirName)

			if (!projectDir.exists()) {
				println "Path ${projectPath} is not relative to the modules dir, so it's probably already okay"

				return projectDependency
			}

			projectPath = fixProjectPath(projectDir)

			"project(\":${projectPath}\")"
		}

		buildGradleFile.text = buildGradle
	}
}

fixShrinkwrap << {
	def shrinkwrapFileTree = fileTree(dir: modulesDir, include: "**/npm-shrinkwrap.json")

	shrinkwrapFileTree.each {
		shrinkwrapFile ->

		shrinkwrapFile.text = shrinkwrapFile.text.replaceAll(/\t+"(?:from|resolved)": "http.+",*\r*\n/, "")
	}
}

initPortalBuild {
	dependsOn deletePortalBuild

	doLast {
		def buildProperties = new Properties()

		def buildPropertiesFiles = new File(portalDir, "build.properties")

		buildPropertiesFiles.withInputStream {
			buildProperties.load it
		}

		def excludes = buildProperties["build.modules.excludes"].tokenize(",")

		["**/bin/", "sdk/*/samples/", "sdk/gradle-templates/classes/", "sdk/gradle-templates/src/"].each {
			excludes.add it
		}

		def includes = buildProperties["build.modules.includes"].tokenize(",")

		def includedFileTree = fileTree(dir: modulesDir, excludes: excludes, includes: includes)

		includedFileTree.each {
			def dir = it.parentFile

			def settingsGradleFile = new File(dir, "settings.gradle")

			if (settingsGradleFile.exists()) {
				return
			}

			def portalBuildFile = new File(dir, "portal.build")

			portalBuildFile.createNewFile()
		}
	}
}

initSeparateRepos << {
	def gitRepoFileTree = fileTree(dir: modulesDir, include: "**/.gitrepo")

	def buildGradleTemplateFile = rootProject.file("separate_repos_build_gradle.tmpl")
	def settingsGradleTemplateFile = rootProject.file("separate_repos_settings_gradle.tmpl")

	def buildGradleTemplate = buildGradleTemplateFile.text.normalize()
	def settingsGradleTemplate = settingsGradleTemplateFile.text.normalize()

	gitRepoFileTree.each {
		gitRepoFile ->

		def gitRepoDir = gitRepoFile.parentFile

		def buildGradleFile = new File(gitRepoDir, "build.gradle")
		def settingsGradleFile = new File(gitRepoDir, "settings.gradle")

		def buildGradleFileTree = fileTree(dir: gitRepoDir, include: "**/build.gradle")

		def buildGradles = buildGradleFileTree.inject("") {
			acc, f ->

			acc += f.text
		}

		def tmpBuildGradleTemplate = buildGradleTemplate

		["lang.merger"].each {
			if (!buildGradles.contains("apply plugin: \"com.liferay.${it}\"")) {
				tmpBuildGradleTemplate = tmpBuildGradleTemplate.replace("\t\tclasspath group: \"com.liferay\", name: \"com.liferay.gradle.plugins.${it}\", version: \"latest.release\"\n", "")
			}
		}

		buildGradleFile.text = tmpBuildGradleTemplate
		settingsGradleFile.text = settingsGradleTemplate

		println "Initialized " + gitRepoDir
	}
}

moveLPS64532 << {
	def buildGradleFiles = fileTree(dir: modulesDir, include: "**/build.gradle")

	def destRootDir = new File(modulesDir, ".releng")
	def modulesDirPath = modulesDir.toPath()

	buildGradleFiles.each {
		buildGradleFile ->

		def dir = buildGradleFile.parentFile

		def relativePath = modulesDirPath.relativize(dir.toPath()).toString()

		def destDir = new File(destRootDir, relativePath)

		destDir.mkdirs()

		["artifact.properties", "src/main/resources/META-INF/liferay-releng.changelog"].each {
			File srcFile = new File(dir, it)

			if (srcFile.exists()) {
				def destFile = new File(destDir, srcFile.name)

				def moved = srcFile.renameTo destFile

				if (moved) {
					println "${srcFile} -> ${destFile}"
				}
				else {
					throw new GradleException("Unable to move ${srcFile} to ${destFile}")
				}
			}
		}
	}
}

moveModules {
	finalizedBy replaceBuildXml
}

moveModules << {
	File marketplaceDir = new File(modulesDir, "apps/marketplace")

	if (marketplaceDir.exists()) {
		throw new GradleException("Please rename " + marketplaceDir + ", it messes with the bnd.bnd relative path replacement")
	}

	def moveDirs = [:]
	def moveParentDirs = new HashSet<File>()

	def movesFile = file("moves.csv")

	def moveLines = movesFile.readLines()

	moveLines.each {
		if (!it.startsWith("modules")) {
			println "Ignoring " + it

			return
		}

		def tokens = it.tokenize(",")

		def oldParentDir = new File(modulesDir.parentFile, tokens[0])
		def dirName = tokens[1]
		def newParentDir = new File(modulesDir, tokens[2])

		moveParentDirs << newParentDir

		def oldDir = new File(oldParentDir, dirName)

		if (!oldDir.exists()) {
			println "Ignoring ${oldDir} because it does not exist"

			return
		}

		def newDir = new File(newParentDir, dirName)

		newParentDir.mkdirs()

		def dir = newParentDir

		while ((dir != null) && (dir != modulesDir)) {
			def buildXmlFile = new File(dir, "build.xml")

			if (!buildXmlFile.exists()) {
				buildXmlFile.text = "REPLACEME!"
			}

			dir = dir.parentFile
		}

		def moved = oldDir.renameTo(newDir)

		if (!moved) {
			throw new GradleException("Unable to move ${oldDir} to ${newDir}")
		}

		println "Moved ${oldDir} to ${newDir}"

		moveDirs[oldDir] = newDir
	}

	Closure doReplace = {
		file, replaceClosure ->

		def content = file.text

		def newContent = content

		moveDirs.each {
			oldDir, newDir ->

			newContent = newContent.replace replaceClosure(oldDir), replaceClosure(newDir)
		}

		if (content != newContent) {
			file.text = newContent

			println "Updated " + file
		}
	}

	if (Boolean.getBoolean("skip.replace")) {
		return
	}

	// Replace relative paths in bnd.bnd

	moveParentDirs.each {
		parentDir ->

		def bndFileTree = fileTree(dir: parentDir, exclude: "**/src/**/*.bnd", include: "**/*.bnd")

		bndFileTree.each {
			bndFile ->

			def bndDir = bndFile.parentFile

			def bndDirPath = bndDir.toPath()

			def content = bndFile.text

			def newContent = content.replaceAll(
				/((?:\.\.\/)+[\w-]+?)\//,
				{
					def pointedFile = new File(bndDir, it[1])

					while (!pointedFile.exists()) {
						def dir = pointedFile.parentFile.parentFile

						if (dir == null) {
							pointedFile = null

							break
						}

						pointedFile = new File(pointedFile.parentFile.parentFile, pointedFile.name)
					}

					if (pointedFile == null) {
						return null
					}

					def pointedPath = bndDirPath.relativize(pointedFile.toPath()).toString()

					return pointedPath.replace(File.separatorChar, '/' as char) + "/"
				})

			if (content != newContent) {
				bndFile.text = newContent

				println "Updated " + bndFile
			}
		}
	}

	// Replace project paths in build.gradle

	def buildGradleFiles = fileTree(dir: modulesDir, include: "**/build.gradle")

	buildGradleFiles.each {
		doReplace it, {
			dir ->

			def modulesDirPath = modulesDir.toPath()

			def path = modulesDirPath.relativize(dir.toPath()).toString()

			path = path.replace(File.separatorChar, ':' as char)
			path = path.replace('/' as char, ':' as char)

			path = "\":" + path + ":"

			return path
		}

		doReplace it, {
			dir ->

			def modulesDirPath = modulesDir.toPath()

			def path = modulesDirPath.relativize(dir.toPath()).toString()

			path = path.replace(File.separatorChar, ':' as char)
			path = path.replace('/' as char, ':' as char)

			path = "\":" + path + "\""

			return path
		}
	}

	// Replace file paths source-formatter.properties and other files

	FileTree fileTree = fileTree(dir: modulesDir.parentFile, includes: ["build.properties", "source-formatter.properties", "modules/**/*.bnd", "modules/**/*.java"])

	fileTree.each {
		doReplace it, {
			dir ->

			def modulesDirPath = modulesDir.toPath()

			def path = modulesDirPath.relativize(dir.toPath()).toString()

			return "modules/" + path.replace(File.separatorChar, '/' as char) + "/"
		}
	}
}

moveStatic << {
	def staticFileTree = fileTree(dir: modulesDir, include: "**/.lfrbuild-static")

	staticFileTree.each {
		def dir = it.parentFile

		println dir
	}
}

printExtensions << {
	if (!project.hasProperty("dir")) {
		throw new GradleException("Please pass -Pdir argument")
	}

	Set<String> extensions = new TreeSet<String>()

	def rootDir = new File(modulesDir, dir)

	rootDir.eachFileRecurse {
		def fileName = it.name

		def pos = fileName.indexOf('.')

		if (pos == -1) {
			return
		}

		extensions << fileName.substring(pos + 1)
	}

	println extensions
}

removeTouch << {
	def touchFileTree = fileTree(dir: modulesDir, include: "**/.touch")

	touchFileTree.each {
		touchFile ->

		def touchFilePath = touchFile.absolutePath

		touchFilePath = touchFilePath.replace(File.separatorChar, '/' as char)

		if (!touchFilePath.endsWith("/src/main/resources/.touch")) {
			println "Ignoring ${touchFile}"

			return
		}

		def srcDir = touchFile.parentFile.parentFile.parentFile

		def testDir = new File(srcDir, "test")
		def testIntegrationDir = new File(srcDir, "testIntegration")

		if (testDir.exists() || testIntegrationDir.exists()) {
			delete touchFile
		}
	}
}

renameBuildFiles << {
	def buildFiles = fileTree(dir: modulesDir, includes: ["**/portal.build", "**/static.build"])

	buildFiles.each {
		def suffix = it.name[0 .. - 7]

		def newFile = new File(it.parentFile, ".lfrbuild-${suffix}")

		def renamed = it.renameTo newFile

		if (renamed) {
			println "Renamed ${it} into ${newFile}"
		}
		else {
			throw new GradleException("Unable to rename ${it} into ${newFile}")
		}
	}
}

replaceBuildXml << {
	def buildXmlFileTree = fileTree(dir: modulesDir, include: "**/build.xml")

	def buildModuleXmlPath = new File(modulesDir, "build-module.xml").toPath()

	buildXmlFileTree.each {
		def buildXmlFile ->

		if (buildXmlFile.parentFile.name != "samples") {
			def parentPath = buildXmlFile.parentFile.toPath()

			def content = buildXmlFile.text

			if (content.contains("build-theme.xml")) {
				return
			}

			def buildModuleXmlFileName = parentPath.relativize(buildModuleXmlPath).toString()

			buildModuleXmlFileName = buildModuleXmlFileName.replace('\\', '/')

			buildXmlFile.text = """\
<?xml version=\"1.0\"?>
<!DOCTYPE project>

<project>
	<import file=\"${buildModuleXmlFileName}\" />
</project>"""
		}
	}
}

replaceProjectDeps << {
	def projectDepsReplacements = [:]

	def group = "com.liferay"

	def groupCacheDir = new File(gradleCacheDir, group)

	def projectDepsFile = file("project_deps.txt")

	projectDepsFile.each {
		projectDep ->

		def index = projectDep.lastIndexOf(":")

		def name = projectDep.substring(index + 1, projectDep.length() - 2)

		def artifactName = group + "." + name.replace('-' as char, '.' as char)

		def artifactCacheDir = new File(groupCacheDir, artifactName)

		if (!artifactCacheDir.exists()) {
			println "Unable to find ${artifactCacheDir}"

			return
		}

		def version = artifactCacheDir.list().first()

		def artifactDep = "group: \"${group}\", name: \"${artifactName}\", version: \"${version}\""

		projectDepsReplacements[projectDep] = artifactDep
	}

	def buildGradleFileTree = fileTree(dir: new File(modulesDir, "ee"), include: "**/build.gradle")

	buildGradleFileTree.each {
		buildGradleFile ->

		def buildGradle = buildGradleFile.text

		projectDepsReplacements.each {
			k, v ->

			buildGradle = buildGradle.replace(k, v)
		}

		buildGradleFile.text = buildGradle
	}
}

wrapper {
	gradleVersion = "2.11"
}

writeSettingsIncludes << {
	def settingsIncludes = []

	def xmlParser = new XmlParser()

	xmlParser.setFeature "http://apache.org/xml/features/disallow-doctype-decl", false

	def buildXmlFile = new File(modulesDir, "build.xml")

	def projectNode = xmlParser.parse(buildXmlFile)

	projectNode.path.dirset.each {
		def node ->

		def dir = node.attribute("dir")
		def excludes = node.attribute("excludes") ?: ""
		def includes = node.attribute("includes") ?: ""

		def dirNames = excludes.tokenize(",")

		dirNames.each {
			def dirName ->

			settingsIncludes << "exclude \"${dir}/${dirName}/build.gradle\""
		}

		dirNames = includes.tokenize(",")

		dirNames.each {
			def dirName ->

			settingsIncludes << "include \"${dir}/${dirName}/build.gradle\""
		}
	}

	settingsIncludes.sort()

	def settingsIncludesFile = file("tmp/settings-includes.gradle")

	settingsIncludesFile.parentFile.mkdirs()

	settingsIncludesFile.withWriter {
		def writer ->

		def previousTitle

		settingsIncludes.each {
			def title = it.substring(0, it.indexOf(' '))

			if (previousTitle && (previousTitle != title)) {
				writer.writeLine
			}

			writer.write "\t\t"
			writer.writeLine it
		}
	}
}

private void _copyLibToCache(Project project, File gradleCacheDir, String libGroup, String libName, String libVersion, String libClassifier) {
	if (!libGroup || !libName || !libVersion) {
		throw new GradleException("libGroup, libName, and libVersion are required")
	}

	String mavenLibGroup = libGroup.replace('.', '/')

	File gradleLibDir = new File(gradleCacheDir, "${libGroup}/${libName}/${libVersion}")
	File mavenLibDir = new File(System.getProperty("user.home"), ".m2/repository/${mavenLibGroup}/${libName}/${libVersion}")

	["jar", "pom"].each {
		String extension ->

		String sourceFileName = "${libName}-${libVersion}"

		if (libClassifier) {
			if (extension != "jar") {
				return
			}

			sourceFileName += "-${libClassifier}"
		}

		sourceFileName += ".${extension}"

		File sourceFile = new File(mavenLibDir, sourceFileName)

		if (!sourceFile.exists()) {
			String sourceUrl = "https://repository.liferay.com/nexus/content/groups/public/${mavenLibGroup}/${libName}/${libVersion}/${sourceFileName}"

			try {
				project.download {
					dest buildDir
					src sourceUrl
				}
			}
			catch (Exception e) {
				println e

				return
			}

			sourceFile = new File(buildDir, sourceFileName)
		}

		String sha1 = _getSHA1(sourceFile)

		project.copy {
			from sourceFile
			into new File(gradleLibDir, sha1)
		}
	}
}

private File _getModuleDir(String dirName) {
	def moduleDir

	modulesDir.traverse(
		preDir: {
			if (it.name == dirName) {
				moduleDir = it

				return FileVisitResult.TERMINATE
			}
		},
		type: FileType.DIRECTORIES
	)

	return moduleDir
}

private String _getSHA1(File file) {
	file.withInputStream {
		String sha1 = DigestUtils.sha1Hex(it)

		StringUtils.stripStart(sha1, "0")
	}
}